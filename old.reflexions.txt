Assertions
  Les messages d'une communication doivent être consommés avant l'envoi d'une
  requête => Si une communication nécessite plusieurs messages, aucun message
  n'appartenant pas à cette communication ne peux s'insérer entre le permier et
  le dernier de cette communication

  Une requete peut arriver alors qu'on attends une réponse
    (Par exemple un cycle dans la recherche)
    On peut utiliser la pile pour différentier les appels (encapsuler l'attente dans une fonction)

Questions

  Que se passe t'il dans le cas d'une insertion de donnée à une coord qui existe
  déjà ? 
  - Coord <=> hash ==> unique pour des données distinctes ???

Types

  Zone
    id_noeud
    minX, maxX
    minY, maxY

  // Liste triée ??
  // TODO crud
  ListeZones
    Zone *z
    ListeZone *next

  ListeDonnes
    int donnee
    int x, y
    ListeDonnes *next;

Types de message

  // Données complémentaires à une requête précédemment envoyée
  // Le nombre de valeur est spécifique à la requête concernée
  DATA (...)

  // Pour les requetes suivantes : la requête est envoyée sans valeur, elle doit
  // être suivie si nécessaire d'une requête DATA

  // Si le noeud initiateur est spécifié, c'est sûrement pour lui envoyer
  // directement la réponse plutôt que de repasser par tous les noeuds
  // intermédiaire.

  // Demander à un noeud de s'insérer dans l'overlay
  // Renvoie un ACK au noeud initiateur
  REQUETE_INSERE_TOI (nd_init)

  // Routage de la requête d'insertion du noeud
  // Après l'insertion, renvoie un ACK au noeud inséré
  REQUETE_INSERTION_NOEUD (noeud, x, y)

  // Demande la mise à jour de la zone du voisin 'noeud'
  // Si le noeud qui reçoit la requête est le même que l'argument, alors il doit
  // mettre à jour sa propre zone
  MAJ_ZONE (noeud, minX, maxX, minY, maxY)
  
  // Routage d'une insertion de valeur
  // Après l'insertion, renvoie un ACK au noeud initiateur
  REQUETE_INSERTION_VALEUR (nd_init, x, y, val)
  
  // Routage d'une recherche de valeur
  // Sur le noeud adéquat, envoi au noeud initiateur de la valeur
  REQUETE_RECHERCHE_VALEUR (nd_init, x, y)

  // Réponse à une requête de recherche de valeur
  // statut vaut soit OK soit KO
  // Dans le cas de KO, la valeur n'est pas pertinente
  REPONSE_RECHERCHE_VALEUR (statut, val)

Variables

  int N // nombre de noeuds

  Zone moi
  int x, y
  Zone *gauche, *bas, *droite, *haut

Fonctions pour chaque noeud

  attendre_message
    recevoir message
    Si type == REQ_INS_ND
      inserer_noeud
    Si type == REQ_INS_VAL
      inserer_val
    Si type == REQ_RECHERCHE
      recherche_noeud
    Sinon
      retour

  boucle principale
    generer x et y
    attendre_message

  lancer_recherche_noeud int x, int y
    send à 1 REQ_RECHERCHE
    send id, x, y
    attendre_message
    recv &noeud

  recherche_noeud
    recevoir int noeud_init, int nd_x, int nd_y
    si nd_x et nd_y appartiennent au noeud
      envoyer id à noeud_init
    sinon si nd_x appartient au noeud
      si nd_y < minY
        Pour tout v dans vB
          si nd_x <= v.maxX
            si nd_x et nd_y appartiennent à v
              envoyer id à noeud_init
            sinon
              send à v REQ_RECHERCHE
              send nd_x, nd_y
            retour
      sinon
        Pour tout v dans vH
          si nd_x <= v.maxX
            si nd_x et nd_y appartiennent à v
              envoyer id à noeud_init
            sinon
              send à v REQ_RECHERCHE
              send nd_x, nd_y
            retour
    sinon si nd_y appartient au noeud
      si nd_x < minX
        Pour tout v dans vG
          si nd_y <= v.maxY
            si nd_x et nd_y appartiennent à v
              envoyer id à noeud_init
            sinon
              send à v REQ_RECHERCHE
              send nd_x, nd_y
            retour
      sinon
        Pour tout v dans vD
          si nd_y <= v.maxY
            si nd_x et nd_y appartiennent à v
              envoyer id à noeud_init
            sinon
              send à v REQ_RECHERCHE
              send nd_x, nd_y
            retour

  inserer_noeud
    Envoyer à 1 REQ_RECHERCHE
    Envoyer à 1 int id, int x, int y
    attendre_message
    Recevoir noeud
    Envoyer à noeud REQ_DIVISER
    attendre_message
    Recevoir minX, maxX, minY, maxY, nvVG, nvVB, nvVD, nvVH
    Recevoir vG, vB, vD, vH
    Pour tout v dans vG, vB, vD, vH
      Envoyer à v REQ_VOISIN
      Envoyer à v id, minX, maxX, minY, maxY

  diviser
    /* L'ancien noeud notifie ses voisins de sa nouvelle zone et de la zone du
    nouveau, il faut bien penser à ajouter le nouveau à l'ancien. Il faudra
    envoyer comme réponse au nouveau ses voisins, y compris l'ancen noeud */
    TODO le reste

  nouveau_voisin
    /* Si l'identifiant fait partie des voisins, on mets à jour la plage, sinon
    on l'ajoute. Si la nouvelle plage n'est pas limitrophe on le supprime */
    TODO le reste

  inserer_valeur
    Envoyer à 1 REQ_RECHERCHE
    Envoyer à 1 int id, int x, int y
    attendre_message
    Recevoir noeud
    

Fonctions pour le coordinateur

  boucle principale
    insérer tous les noeuds
    insérer des valeurs
    rechercher des valeurs

  inserer_valeur
    Envoyer à 1 REQ_RECHERCHE
    Envoyer à 1 int x, int y, int val
    attendre_message

